# MySQLを使う人がPostgreSQLを使うときに知っておくべきこと
このドキュメントでは、MySQLを使う人がPostgreSQLを使うときに知っておくべき基本的な操作や概念の違いについて説明します。

# 目次
1. インストール
1. DDL
1. インデックス
1. JSON型
1. レプリケーション
1. ユーザと権限
1. バックアップとリストア

# インストール
MySQLとPostgreSQLのインストール方法は異なります。
以下にPostgreSQLの基本的なインストール手順を示します。

## コマンドによるインストール

パッケージ管理システムを使用してPostgreSQLをインストールします。

```bash
# Ubuntu/Debian
sudo apt update
sudo apt install postgresql postgresql-contrib
```

データベースを作成します。

```bash
sudo -i -u postgres
createuser -P dbuser
# --no-locale と locakle=Cは同義
-- オプションを指定しない場合はOSのエンコード、ロケールが使われる
createdb -E UTF8 --locale=C --template=template0 mydb
psql mydb

mydb=# SELECT name, setting, context FROM pg_settings WHERE name LIKE 'lc%';
name | setting | context
-------------+---------+-----------
lc_collate | C | internal
lc_ctype | C | internal
lc_messages | C | superuser
lc_monetary | C | user
lc_numeric | C | user
lc_time | C | user

mydb=# SHOW client_encoding;
```

大きな注意点としてエンコードとロケールは必ず設定するようにしましょう。
ここは後から変更できません。つまり、実務上問題がでた場合、データベースを再作成し、データを移行する必要があります。
当然、データが大きくなり、ダウンタイムが許されない場合は難易度の高い作業になります。

## PostgreSQLのTemplate
PostgreSQLではデータベースを作成する際に、templateという仕組みを使います。
template0はPostgreSQLがインストールされた直後の状態を保持しているテンプレートです。
template1はtemplate0を元に、ユーザが作成したオブジェクトを含むテンプレートです。
Templateを指定されない場合、通常はtemplate1を使いますが、エンコードやロケールを変更したい場合はtemplate0を指定して、データベースを作成する必要があります。
そのためtemplate0を使うために、`--template=template0` を指定します。

実務の例では、RDSのPostgreSQLを使う場合に、RDSのPostgreSQLはtemplate1を変更できないため、template0を指定してデータベースを作成する必要があります。

## 文字コードとロケールの設定
PostgreSQLはデータベースの際にロケールを指定しない場合、OS側に設定されているロケールを使用します。日本語の環境ならja_JP.UTF-8が選ばれます。
しかし、RDSの場合は `en_US.UTF-8` が選ばれます。これに伴いDBが壊れることはありませんし、エラーなどもありません。ただし、文字コードに関する細かいソートやチェックなど文字関連に影響し、OSに依存してしまうことから、意図しない挙動をすることがあります。
特に開発環境において、OSのロケールが異なる場合、同じクエリであっても異なる結果になることがありますので統一するようにしましょう。

それを防ぐためにPostgreSQLでは一般的に、エンコードとロケールとして明示的指定します。
一般的にはロケールにはCを指定します。これにより、OSに依存することなく、バイナリ値を基準にした一定のソートが行われ、ORDER BYの性能も向上します。

ロケールにCを指定するには、前述の手順のとおり--no-localeを指定するか、--locale=Cを指定します。--no-localeと--locale=Cは同義ですのでどちらでもかまいません。

エンコードは多くの環境ではデフォルトでUTF8が指定されますが、念のため-E UTF8を指定することをお勧めします。
古い環境などの場合には、デフォルトがSQL_ASCIIになっている場合があります。
SQL_ASCIIの場合はマルチバイト文字が文字化けすることになり、実務では運用できないため、必ずUTF8を指定するようにしましょう。

再三の注意ですが、もし指定し忘れた場合、基本的にはDBを作りなおすことになるため、無停止では変更できないと思ってください。運用が走り出すと変更がしにくい箇所ですので、最初の構築が重要です

## 注意点
PostgreSQLに限らず、MySQLでも同様ですが、データベースを作成時は必ずTimeZoneを確認しましょう。
こちらもデフォルトではOSのタイムゾーンが使われます。
しかしRDSのデフォルトはUTCになっているため、容易に開発環境と本番環境でタイムゾーンが異なることになり、意図しない挙動をすることがあります。
特にtimestamp with timezone型を使う場合に意図しない時間が保存されることで、時間がずれることになります。

ただし、PostgreSQLでもtimezoneはあとから `set timezone 'Asia/Tokyo';` のように変更できますが、データのズレは修正が必要になるため、やはり最初に確認することが重要です。

## アクセス制限
PostgreSQLのアクセス制限はpg_hba.confというファイルとpostgresql.confというファイルで設定します。
pg_hba.confはホストベースのアクセス制御を行うファイルで、接続元IPアドレス、データベース名、ユーザ名、認証方法などを設定します。
postgresql.confはPostgreSQLの全般的な設定を行うファイルで、リスニングアドレス、ポート番号、ログ設定などを設定します。

これらのファイルはPostgreSQLのデータディレクトリにあります。
通常、デフォルトではlocalhostからの接続のみ許可されています。
外部からの接続を許可する場合は、pg_hba.confに適切な設定を追加し、postgresql.confでlisten_addressesを設定する必要があります。
設定を変更した後は、PostgreSQLを再起動する必要があります。
RDSｎ場合は、自然と設定されているので、特に意識する必要はありませんが、ローカルの開発環境等でPostgreSQLを使う場合は注意してください。

# DDL
MySQLとPostgreSQLのDDLにはいくつかの違いがあります。以下に主要な違いを示します。

## CREATE INDEX CONCURRENTLY
PostgreSQLでは、インデックスを作成する際に`CONCURRENTLY`オプションを使用することで、テーブルのロックを最小限に抑えながらインデックスを作成できます。これにより、インデックス作成中もテーブルへの読み書きが可能です。

```sql
-- 書き込みを止めずに作る（失敗してもテーブルはそのまま）
CREATE INDEX CONCURRENTLY idx_orders_created_at
  ON orders (created_at);

-- 併走DDLの可視化（作成中の未VALIDなindex監視）
SELECT schemaname, tablename, indexname, indisvalid
FROM pg_indexes AS i
JOIN pg_class   AS c   ON c.relname = i.indexname
JOIN pg_index   AS idx ON idx.indexrelid = c.oid
WHERE NOT idx.indisvalid;
```

CREATE INDEX CONCURRENTLYはロックをとらないというメリットの反面、テーブルスキャンを2回行うため、通常のCREATE INDEXよりも時間がかかります。インデックス作成時に追加されたデータを後から反映させるために、2回目のスキャンが必要になるためです。
またインデックス作成中にDDLが走ると失敗することがありますし、データの更新量が多いと作成が追い付かず、失敗することがあります。
そのため、インデックス作成中に大量の更新が発生することが予想される場合は、メンテナンスウィンドウを設けて、ロックを取った通常のCREATE INDEXを使用するか、新たなテーブルやカラムを追加して、インデックスを作成し、データを移行する方法を検討してください。

## idの指定
MySQLのAUTO_INCREMENTに相当するものとして、PostgreSQLではSERIAL型やIDENTITY型があります。
どちらもMySQLと同様にintの範囲で自動的に連番を生成しますが、SERIAL型はPostgreSQLのバージョン10以降では非推奨となり、IDENTITY型の使用が推奨されています。

```sql
-- 基本形：アプリがIDを明示しない想定（多くのケース）
CREATE TABLE users (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name text NOT NULL
);

-- どうしてもアプリからIDを入れさせたくない場合
CREATE TABLE strict_users (
  id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
  name text NOT NULL
);

-- ALWAYS では手動INSERTはエラー。入れるなら:
-- INSERT ... OVERRIDING SYSTEM VALUE ...
-- BY DEFAULT … 値を指定したら“その値”を採用。未指定なら自動採番。
-- ALWAYS … 原則、常に自動採番。手動値は不可（ただし OVERRIDING SYSTEM VALUE を明示した場合のみ受け入れ）
```

IDENTITY型については、日本語では識別型と翻訳されており、公式ドキュメントでは識別型になっています。
MySQLとは違う大きな特徴の一つなのでドキュメントをチェックしておきましょう。
[PostgreSQL 識別型](https://www.postgresql.jp/docs/current/ddl-identity-columns.html)

